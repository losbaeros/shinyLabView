---
title: "ShinyLabView"
output: 
  flexdashboard::flex_dashboard:
    theme: sandstone
runtime: shiny
---

```{r global, include=FALSE}
library(dplyr)
library(lubridate)
library(DT)
labData <- read.csv("./labData.csv") # loading data in global needs to be done only once.
patData <- read.csv2("./patientData.csv")
normValues <- read.csv2("./normValues.csv")
combinedData <- merge(labData, patData, by = "patientId")

# build normvalues for display later
femaleNormValues <- c()
maleNormValues <- c()
for (i in 1:nrow(normValues)) {
  femaleNormValues <- c(femaleNormValues, paste(as.character(normValues[i, "female.min"]),
                                                "-",
                                                as.character(normValues[i, "female.max"]),
                                                as.character(normValues[i, "unit"]))
                        )
  maleNormValues <- c(maleNormValues, paste(as.character(normValues[i, "male.min"]),
                                            "-",
                                            as.character(normValues[i, "male.max"]),
                                            as.character(normValues[i, "unit"]))
                      )
}
```

Lab Results {data-orientation=rows}
=======================================================================

Column {.sidebar}
-----------------------------------------------------------------------
```{r}
# prepare patient selection with helper vector:
# - selectInput takes a named vector to display names coded with an id:
#   See: http://shiny.rstudio.com/reference/shiny/latest/selectInput.html
#   and: https://www.dummies.com/programming/r/how-to-name-the-values-in-your-vectors-in-r/
patData <- patData[order(patData$name), ]
patSelectors <- patData$patientId
names(patSelectors) <- paste(as.character(patData$name), 
                             as.character(patData$firstName),
                             sep = ", ")

selectInput("patId", 
            label = h4("Select Patient:"),
            choices = patSelectors)
```

Row
-----------------------------------------------------------------------
### Lab results
```{r}
h4(renderText({
  paste("Patient:",
        as.character(patData[patData$patientId == input$patId, "firstName"]),
        as.character(patData[patData$patientId == input$patId, "name"]),
        "(",
        as.character(patData[patData$patientId == input$patId, "sex"]),
        ")",
        "age:",
        as.character(patData[patData$patientId == input$patId, "age"]))
}))

# "prettify" data for output
combinedData$date <- as_datetime(combinedData$date, 
                                 origin = lubridate::origin, 
                                 tz = "UTC") # convert int to unixTs-obj using lubridate
combinedData$date <- format(combinedData$date, 
                            format = "%y-%m-%d %H:%M") # convert unixTs to human readable string
# round to reasonable values (using dplyr)
combinedData <- mutate_at(combinedData, vars(na, k, krea, hst), funs(round(., 2)))
combinedData <- mutate_at(combinedData, vars(gfr, hgb, inr, rbc, wbc), funs(round(., 1)))
combinedData <- mutate_at(combinedData, vars(gfr, plt, ptt), funs(round(., 0)))

# build a reactive component for DT
displayData <- reactive({ 
  displayData <- combinedData[combinedData$patientId == input$patId, ] # select by patientId
  displayData <- displayData[order(displayData$date, decreasing = TRUE), ] # sort by date
  rownames(displayData) <- displayData$date # set date as rowname (can't be done earlier, because of likely duplicates)
  displayData <- subset(displayData, select = c(na, k, krea, hst, gfr, hgb, rbc, plt, wbc, inr, ptt)) # select values (if not done here normValues will be false!)
  
  # Bind sex-specific normValues to table
  if (patData[patData$patientId == input$patId, "sex"] == "f") {
    displayData <- rbind(femaleNormValues, displayData)
  } else {
    displayData <- rbind(maleNormValues, displayData)
  }
  rownames(displayData) <- c("norm", rownames(displayData)[-1]) # replace default rowname
  
  displayData <- t(displayData) # transpose table (in order to get that sweet "Kummulativbericht-feeling")
})

# render DT output
DT::renderDataTable( # see: https://rstudio.github.io/DT/options.html
  datatable( # using a seperate datatable-obj. to enable formatStyle
    data = displayData(),
    class = "white-space: nowrap", # disable linebreaks: https://github.com/rstudio/DT/issues/353#issuecomment-244509696
    extensions = c("FixedColumns"),
    selection = list(mode = "single", target = "row"), # https://rstudio.github.io/DT/shiny.html
    options = list(ordering = FALSE, # ordering makes no sense in a turned table
                   paging = FALSE, # display all avail rows on one site (no problem since table is transposed)
                   searching = FALSE, # disable searchbar
                   bInfo = FALSE, # disable "Showing .. of .. Values"
                   scrollX = TRUE, # enable horizontal scolling
                   fixedColumns = list(leftColumns = 2), # fix columns
                   autoWidth = TRUE) # (https://github.com/rstudio/DT/issues/29#issuecomment-85222039)
  ) 
  # style Columns
  %>% formatStyle(0, backgroundColor = "lightgrey", fontWeight = "bold", pointerEvents = "none") # see write_along.Rmd regarding pointerEvents = "none"
  %>% formatStyle(1, backgroundColor = "lightgrey", fontSize = "xx-small", pointerEvents = "none")
)
```
